2024-12, Silver problem2

**问题描述**

N棵树，种在N个位置上，所有位置在一条直线上，给出K条限制，每条限制是[li,ri]的位置区间（包含两端）至少保留ti棵树。初始的时候满足所有限制条件。

**问题**：在满足所有的限制条件下，最多能砍掉多少棵树？

**分析过程**
-  经典贪心问题，如果简单一点可以是每条限制条件[li,ri]内至少有固定数字的树，比如（至少1棵树，或者m棵树），假设是每个区间至少保持1棵树。

   将所有的限制条件区间按照**ri**排序，从ri最大的开始依次处理。（当其他区间都不能为这个区间做出贡献的时候，这个区间只能依靠自己去满足限制条件）
   <img width="809" alt="image" src="https://github.com/user-attachments/assets/be7ee17d-3a2d-446e-bfc0-70e138aea3b9" />

   -  如图中，优先处理[2,8]，从右侧位置8开始向左侧位置2循环找到第1棵树进行保留，并对already_remain的位置的树进行标记。
   -  再处理[3,6],看区间内是不是已经满足了保留1棵树的条件，不满足则从右侧位置6开始向左侧位置2进行循环，找到第1棵树进行保留，并标记对应位置的树。
   -  再处理[1,5],最后处理[2,4]，具体方法和上面的一样。
   -  全部树的数量减去alread_remain标记的树的数量，就是可以砍掉的最大树的数量。
-  回到本题，每个限制条件内[li,ri] 至少保留ti棵树，过程与上面相似，至少每个区间处理的时候，需要从右侧位置循环到左侧位置，贪心的标记ti棵already_remain的树。
-  过程中，需要多次查询[li,ri]内的树的数量，很容易想到提前建立前缀和的结构（每个位置i之前的总树量)，还需要考虑砍掉树意味着节点有变化，前缀和需要更新。
-  为了平衡区间查询和节点更新的处理速度，数据结构采用FenwickTree（二叉索引树）来加快查询区间位置内树的数量。
    <img width="944" alt="image" src="https://github.com/user-attachments/assets/995d0ede-a6a3-440b-ba07-1e96efe30a81" />

剩下的就是写代码实现了～

  
