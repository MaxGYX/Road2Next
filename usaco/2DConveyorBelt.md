2024-12, Silver problem3

**问题描述**

NxN的格子上，格子(a,b)代表从上面开始的第a行，从左边开始的第b列的格子。每个格子上可以安置传送带，传送带共5种类型：
-  “L”：每单位时间可以将物品向左传送1格
-  “R”：每单位时间可以将物品向右传送1格
-  “U”：每单位时间可以将物品向上传送1格
-  “D”：每单位时间可以将物品向下传送1格
-  “？”：格子上还未建立传送带
每个格子可以将物品传送到区域外部。如果一个格子c永远都无法将其中的物品传送到区域外，则定义格子c为unusable。

开始的时候，所有格子都是“？”类型，然后在Q天内，每一天John都选择一个没有传送带的格子（即类型为？）建造传送带。即，第i天，John在(ri,ci)的格子上建造传送带，类型为（L，R，U，D）中的其中之一。

**问题：**

在满足所有的限制条件下，最多能砍掉多少棵树？

**分析过程**

**不考虑执行效率**，可以从第一天开始，构建每天NxN格子的状态，对于每一天，

* 从最外层格子开始统计能传送出去格子，并标记访问过的格子。
* 对于每个能传送出去的格子，判断其相邻的4个格子情况（未访问过且能过到达这个格子的，进入能传送出去的格子列表，注意每个内存的格子都需要到达外层能出去的格子，才能被传送到区域外部），并标记访问过的格子。
* 当能传送出去的格子全部遍历处理完，即可以得到全部能出去的格子数，全部格子-？数量-能出去的格子数=ununsable的数量。
  
**考虑执行效率**，每一天都这么处理，应该无法通过所有case。

* 可以从最后一天开始，按照上述流程判断最后一天的unusable数量。然后依次处理前一天（反向处理）
* 倒数第二天，实际就是将最后一天的建造的格子类型变成？
    * 如果这个格子原来是unusable，那么会变成？就不是unusable了，并不影响其他格子。
    * 如果这个格子原来不是unusable的（即能出去），现在变成？后格子本身仍然不是unusable，但是会影响到其他通过这个格子出去的格子（内圈或者本圈的格子，不影响外圈格子，因为只有本圈或者外圈格子可能通过它出去）
    * 那么只需要找出被它影响的周边4个格子（可能受影响变成unusable），并继续处理受到迭代处理的格子（可以DFS深度优先搜索）。
* 按照上面的逻辑依次处理前一天。


程序逻辑还是挺复杂的，因为？不属于unusable，要很小心的处理逻辑，写出来应该有bug，没找出来，只通过了5个case，可能还不如暴力枚举每一天的情况通过的case多 😓
